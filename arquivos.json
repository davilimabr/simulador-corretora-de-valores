[
  {
    "diretorio": "package.json",
    "conteudo": "{\n  \"name\": \"simulador-corretora-api\",\n  \"version\": \"1.0.0\",\n  \"description\": \"API RESTful que simula uma corretora de valores (Trabalho DSW 2025)\",\n  \"main\": \"src/server.js\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"dev\": \"nodemon src/server.js\",\n    \"start\": \"node src/server.js\",\n    \"migrate\": \"sequelize-cli db:migrate\"\n  },\n  \"dependencies\": {\n    \"bcrypt\": \"^5.1.1\",\n    \"body-parser\": \"^1.20.2\",\n    \"dotenv\": \"^16.5.0\",\n    \"express\": \"^4.19.2\",\n    \"jsonwebtoken\": \"^9.0.2\",\n    \"moment\": \"^2.30.1\",\n    \"mysql2\": \"^3.10.0\",\n    \"node-fetch\": \"^3.3.2\",\n    \"sequelize\": \"^7.7.0\"\n  },\n  \"devDependencies\": {\n    \"nodemon\": \"^3.1.0\",\n    \"sequelize-cli\": \"^6.7.0\"\n  }\n}\n"
  },
  {
    "diretorio": ".env.example",
    "conteudo": "PORT=3000\nDB_HOST=localhost\nDB_PORT=3306\nDB_NAME=corretora_db\nDB_USER=root\nDB_PASS=senha\nJWT_SECRET=segredo-super-seguro\n"
  },
  {
    "diretorio": "src/server.js",
    "conteudo": "import app from './app.js';\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\nconst PORT = process.env.PORT || 3000;\n\napp.listen(PORT, () => {\n  console.log(`ðŸš€ API Simulador Corretora ouvindo em http://localhost:${PORT}`);\n});\n"
  },
  {
    "diretorio": "src/app.js",
    "conteudo": "import express from 'express';\nimport bodyParser from 'body-parser';\nimport dotenv from 'dotenv';\nimport helmet from 'helmet';\nimport routes from './routes/index.js';\nimport './config/database.js';\n\ndotenv.config();\n\nconst app = express();\napp.use(helmet());\napp.use(bodyParser.json());\n\n// Rotas\napp.use('/api', routes);\n\n// 404 handler\napp.use((req, res) => res.status(404).json({ error: 'Endpoint nÃ£o encontrado' }));\n\nexport default app;\n"
  },
  {
    "diretorio": "src/config/database.js",
    "conteudo": "import { Sequelize } from 'sequelize';\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\nconst sequelize = new Sequelize({\n  host: process.env.DB_HOST,\n  port: process.env.DB_PORT,\n  database: process.env.DB_NAME,\n  username: process.env.DB_USER,\n  password: process.env.DB_PASS,\n  dialect: 'mysql',\n  logging: false\n});\n\n// Importa modelos\nimport '../models/index.js';\n\nexport default sequelize;\n"
  },
  {
    "diretorio": "src/models/index.js",
    "conteudo": "import sequelize from '../config/database.js';\nimport { DataTypes } from 'sequelize';\n\nexport const Usuario = sequelize.define('Usuario', {\n  id: { type: DataTypes.INTEGER, autoIncrement: true, primaryKey: true },\n  email: { type: DataTypes.STRING, unique: true, allowNull: false },\n  senhaHash: { type: DataTypes.STRING, allowNull: false },\n  ultimaHoraNegociacao: { type: DataTypes.STRING, defaultValue: '14:00' },\n  tokenRecSenha: { type: DataTypes.STRING },\n  dataTokenRS: { type: DataTypes.DATE }\n});\n\nexport const AcaoInteresse = sequelize.define('AcaoInteresse', {\n  id: { type: DataTypes.INTEGER, autoIncrement: true, primaryKey: true },\n  ticker: { type: DataTypes.STRING, allowNull: false },\n  ordem: { type: DataTypes.INTEGER, allowNull: false }\n});\n\nexport const OrdemCompra = sequelize.define('OrdemCompra', {\n  id: { type: DataTypes.INTEGER, autoIncrement: true, primaryKey: true },\n  ticker: DataTypes.STRING,\n  quantidade: DataTypes.INTEGER,\n  modo: DataTypes.ENUM('mercado','abaixo_de_preco'),\n  precoReferencia: DataTypes.DECIMAL(10,2),\n  precoExecucao: DataTypes.DECIMAL(10,2),\n  status: { type: DataTypes.ENUM('pendente','executada'), defaultValue: 'pendente' },\n  dataHoraExecucao: DataTypes.DATE\n});\n\nexport const OrdemVenda = sequelize.define('OrdemVenda', {\n  id: { type: DataTypes.INTEGER, autoIncrement: true, primaryKey: true },\n  ticker: DataTypes.STRING,\n  quantidade: DataTypes.INTEGER,\n  modo: DataTypes.ENUM('mercado','a_partir_de_preco'),\n  precoReferencia: DataTypes.DECIMAL(10,2),\n  precoExecucao: DataTypes.DECIMAL(10,2),\n  status: { type: DataTypes.ENUM('pendente','executada'), defaultValue: 'pendente' },\n  dataHoraExecucao: DataTypes.DATE\n});\n\nexport const CarteiraItem = sequelize.define('CarteiraItem', {\n  id: { type: DataTypes.INTEGER, autoIncrement: true, primaryKey: true },\n  ticker: DataTypes.STRING,\n  quantidade: DataTypes.INTEGER,\n  precoCompraMedio: DataTypes.DECIMAL(10,2)\n});\n\nexport const ContaCorrente = sequelize.define('ContaCorrente', {\n  id: { type: DataTypes.INTEGER, autoIncrement: true, primaryKey: true },\n  dataHora: DataTypes.DATE,\n  descricao: DataTypes.STRING,\n  tipo: DataTypes.ENUM('deposito','retirada'),\n  valor: DataTypes.DECIMAL(10,2),\n  saldoApos: DataTypes.DECIMAL(10,2)\n});\n\n// AssociaÃ§Ãµes\nUsuario.hasMany(AcaoInteresse, { foreignKey: 'usuarioId', onDelete: 'CASCADE' });\nAcaoInteresse.belongsTo(Usuario, { foreignKey: 'usuarioId' });\n\nUsuario.hasMany(OrdemCompra, { foreignKey: 'usuarioId', onDelete: 'CASCADE' });\nUsuario.hasMany(OrdemVenda, { foreignKey: 'usuarioId', onDelete: 'CASCADE' });\n\nUsuario.hasMany(CarteiraItem, { foreignKey: 'usuarioId', onDelete: 'CASCADE' });\nUsuario.hasMany(ContaCorrente, { foreignKey: 'usuarioId', onDelete: 'CASCADE' });\n\nexport default sequelize;\n"
  },
  {
    "diretorio": "src/middlewares/authMiddleware.js",
    "conteudo": "import jwt from 'jsonwebtoken';\nimport dotenv from 'dotenv';\nimport { Usuario } from '../models/index.js';\n\ndotenv.config();\n\nexport async function authMiddleware(req, res, next) {\n  const authHeader = req.headers['authorization'];\n  if (!authHeader) return res.status(401).json({ error: 'Token nÃ£o fornecido' });\n  const token = authHeader.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, process.env.JWT_SECRET);\n    const user = await Usuario.findByPk(decoded.id);\n    if (!user) return res.status(401).json({ error: 'UsuÃ¡rio invÃ¡lido' });\n    req.user = user; // anexa usuÃ¡rio Ã  request\n    next();\n  } catch (err) {\n    return res.status(401).json({ error: 'Token invÃ¡lido' });\n  }\n}\n"
  },
  {
    "diretorio": "src/services/priceService.js",
    "conteudo": "import fetch from 'node-fetch';\nimport moment from 'moment';\n\nconst BASE_URL = 'https://raw.githubusercontent.com/marciobarros/dsw-simulador-corretora/refs/heads/main';\n\nexport async function getClosingPrices() {\n  const resp = await fetch(`${BASE_URL}/tickers.json`);\n  return await resp.json();\n}\n\nexport async function getMinutePrices(minute) {\n  const resp = await fetch(`${BASE_URL}/${minute}.json`);\n  return await resp.json();\n}\n\nexport function mapPricesWithVariation(minutePrices, closingPrices) {\n  return minutePrices.map((p) => {\n    const close = closingPrices.find((c) => c.ticker === p.ticker)?.fechamento ?? p.preco;\n    const variacaoNominal = Number((p.preco - close).toFixed(2));\n    const variacaoPercentual = Number(((variacaoNominal / close) * 100).toFixed(2));\n    return {\n      ticker: p.ticker,\n      precoAtual: p.preco,\n      variacaoNominal,\n      variacaoPercentual,\n      corVariacao: variacaoNominal >= 0 ? 'verde' : 'vermelho'\n    };\n  });\n}\n\nexport async function loadMarketSnapshot(minute) {\n  const [minutePrices, closing] = await Promise.all([\n    getMinutePrices(minute),\n    getClosingPrices()\n  ]);\n  return mapPricesWithVariation(minutePrices, closing);\n}\n"
  },
  {
    "diretorio": "src/services/clockService.js",
    "conteudo": "import moment from 'moment';\n\nexport function advanceClock(currentHHMM, incremento) {\n  const date = moment(`2000-01-01 ${currentHHMM}`, 'YYYY-MM-DD HH:mm');\n  const newDate = date.add(incremento, 'minutes');\n  return newDate.format('HH:mm');\n}\n"
  },
  {
    "diretorio": "src/services/orderExecutionService.js",
    "conteudo": "import { OrdemCompra, OrdemVenda, CarteiraItem, ContaCorrente } from '../models/index.js';\nimport sequelize from '../config/database.js';\n\nexport async function executePendingOrders(usuarioId, marketData) {\n  // marketData: array { ticker, precoAtual }\n  const t = await sequelize.transaction();\n  try {\n    // COMPRA\n    const compPendentes = await OrdemCompra.findAll({ where: { usuarioId, status: 'pendente' }, transaction: t, lock: t.LOCK.UPDATE });\n    for (const ordem of compPendentes) {\n      const precoAtual = marketData.find((m) => m.ticker === ordem.ticker)?.precoAtual;\n      if (!precoAtual) continue;\n      const condicao = ordem.modo === 'mercado' || precoAtual <= ordem.precoReferencia;\n      if (!condicao) continue;\n      await processCompra(ordem, precoAtual, t);\n    }\n\n    // VENDA\n    const vendPendentes = await OrdemVenda.findAll({ where: { usuarioId, status: 'pendente' }, transaction: t, lock: t.LOCK.UPDATE });\n    for (const ordem of vendPendentes) {\n      const precoAtual = marketData.find((m) => m.ticker === ordem.ticker)?.precoAtual;\n      if (!precoAtual) continue;\n      const condicao = ordem.modo === 'mercado' || precoAtual >= ordem.precoReferencia;\n      if (!condicao) continue;\n      await processVenda(ordem, precoAtual, t);\n    }\n\n    await t.commit();\n  } catch (err) {\n    await t.rollback();\n    console.error('Erro executando ordens pendentes', err);\n  }\n}\n\nasync function processCompra(ordem, precoExecucao, t) {\n  const valorTotal = ordem.quantidade * precoExecucao;\n  // Busca Ãºltimo saldo\n  const ultLanc = await ContaCorrente.findOne({ where: { usuarioId: ordem.usuarioId }, order: [['dataHora','DESC']], transaction: t });\n  const saldoAtual = ultLanc?.saldoApos ?? 0;\n  if (saldoAtual < valorTotal) return; // fundos insuficientes\n  const novoSaldo = saldoAtual - valorTotal;\n  await ContaCorrente.create({\n    usuarioId: ordem.usuarioId,\n    dataHora: new Date(),\n    descricao: `Compra ${ordem.quantidade} ${ordem.ticker}`,\n    tipo: 'retirada',\n    valor: valorTotal,\n    saldoApos: novoSaldo\n  }, { transaction: t });\n  // Atualiza carteira\n  const item = await CarteiraItem.findOne({ where: { usuarioId: ordem.usuarioId, ticker: ordem.ticker }, transaction: t, lock: t.LOCK.UPDATE });\n  if (!item) {\n    await CarteiraItem.create({ usuarioId: ordem.usuarioId, ticker: ordem.ticker, quantidade: ordem.quantidade, precoCompraMedio: precoExecucao }, { transaction: t });\n  } else {\n    const totalAnterior = item.quantidade * item.precoCompraMedio;\n    const novoTotal = totalAnterior + valorTotal;\n    const novaQtde = item.quantidade + ordem.quantidade;\n    item.quantidade = novaQtde;\n    item.precoCompraMedio = novoTotal / novaQtde;\n    await item.save({ transaction: t });\n  }\n  // fecha ordem\n  ordem.status = 'executada';\n  ordem.precoExecucao = precoExecucao;\n  ordem.dataHoraExecucao = new Date();\n  await ordem.save({ transaction: t });\n}\n\nasync function processVenda(ordem, precoExecucao, t) {\n  const item = await CarteiraItem.findOne({ where: { usuarioId: ordem.usuarioId, ticker: ordem.ticker }, transaction: t, lock: t.LOCK.UPDATE });\n  if (!item || item.quantidade < ordem.quantidade) return; // nÃ£o possui aÃ§Ãµes suficientes\n  const valorTotal = ordem.quantidade * precoExecucao;\n  // dÃ©bito na carteira\n  item.quantidade -= ordem.quantidade;\n  await item.save({ transaction: t });\n  // crÃ©dito conta corrente\n  const ultLanc = await ContaCorrente.findOne({ where: { usuarioId: ordem.usuarioId }, order: [['dataHora','DESC']], transaction: t });\n  const saldoAtual = ultLanc?.saldoApos ?? 0;\n  const novoSaldo = saldoAtual + valorTotal;\n  await ContaCorrente.create({\n    usuarioId: ordem.usuarioId,\n    dataHora: new Date(),\n    descricao: `Venda ${ordem.quantidade} ${ordem.ticker}`,\n    tipo: 'deposito',\n    valor: valorTotal,\n    saldoApos: novoSaldo\n  }, { transaction: t });\n  // fecha ordem\n  ordem.status = 'executada';\n  ordem.precoExecucao = precoExecucao;\n  ordem.dataHoraExecucao = new Date();\n  await ordem.save({ transaction: t });\n}\n"
  },
  {
    "diretorio": "src/controllers/authController.js",
    "conteudo": "import bcrypt from 'bcrypt';\nimport jwt from 'jsonwebtoken';\nimport dotenv from 'dotenv';\nimport { Usuario } from '../models/index.js';\n\ndotenv.config();\n\nexport async function register(req, res) {\n  const { email, senha } = req.body;\n  if (!email || !senha) return res.status(400).json({ error: 'Email e senha obrigatÃ³rios' });\n  try {\n    const existing = await Usuario.findOne({ where: { email } });\n    if (existing) return res.status(400).json({ error: 'Email jÃ¡ estÃ¡ em uso' });\n    const senhaHash = await bcrypt.hash(senha, 10);\n    const user = await Usuario.create({ email, senhaHash });\n    return res.status(201).json({ userId: user.id, message: 'Conta criada com sucesso' });\n  } catch (err) {\n    return res.status(500).json({ error: 'Erro no servidor' });\n  }\n}\n\nexport async function login(req, res) {\n  const { email, senha } = req.body;\n  const user = await Usuario.findOne({ where: { email } });\n  if (!user) return res.status(401).json({ error: 'Credenciais invÃ¡lidas' });\n  const match = await bcrypt.compare(senha, user.senhaHash);\n  if (!match) return res.status(401).json({ error: 'Credenciais invÃ¡lidas' });\n  const token = jwt.sign({ id: user.id }, process.env.JWT_SECRET, { expiresIn: '12h' });\n  return res.json({ token, userId: user.id, ultimaHoraNegociacao: user.ultimaHoraNegociacao });\n}\n\nexport function logout(_req, res) {\n  // Para JWT, logout Ã© responsabilidade do client (descartar token). Opcional: blacklist em cache.\n  return res.json({ message: 'Logout realizado com sucesso' });\n}\n\nexport async function requestResetToken(req, res) {\n  const { email } = req.body;\n  const user = await Usuario.findOne({ where: { email } });\n  if (user) {\n    user.tokenRecSenha = Math.random().toString(36).substring(2, 10);\n    user.dataTokenRS = new Date();\n    await user.save();\n    console.log(`Token para reset de senha (envio simulado): ${user.tokenRecSenha}`);\n  }\n  return res.json({ message: 'Se o email estiver registrado, vocÃª receberÃ¡ instruÃ§Ãµes.' });\n}\n\nexport async function resetPassword(req, res) {\n  const { tokenRecSenha, novaSenha } = req.body;\n  const user = await Usuario.findOne({ where: { tokenRecSenha } });\n  if (!user) return res.status(400).json({ error: 'Token invÃ¡lido ou expirado' });\n  const diff = (Date.now() - new Date(user.dataTokenRS).getTime()) / 1000 / 60; // minutos\n  if (diff > 60) return res.status(400).json({ error: 'Token expirado' });\n  user.senhaHash = await bcrypt.hash(novaSenha, 10);\n  user.tokenRecSenha = null;\n  await user.save();\n  return res.json({ message: 'Senha redefinida com sucesso' });\n}\n\nexport async function changePassword(req, res) {\n  const { senhaAtual, novaSenha } = req.body;\n  const user = req.user;\n  const match = await bcrypt.compare(senhaAtual, user.senhaHash);\n  if (!match) return res.status(400).json({ error: 'Senha atual incorreta' });\n  user.senhaHash = await bcrypt.hash(novaSenha, 10);\n  await user.save();\n  return res.json({ message: 'Senha alterada com sucesso' });\n}\n"
  },
  {
    "diretorio": "src/controllers/marketController.js",
    "conteudo": "import { advanceClock } from '../services/clockService.js';\nimport { loadMarketSnapshot } from '../services/priceService.js';\nimport { AcaoInteresse, Usuario } from '../models/index.js';\nimport { executePendingOrders } from '../services/orderExecutionService.js';\n\nexport async function clockTick(req, res) {\n  const inc = parseInt(req.body.incrementoMinutos || 1, 10);\n  const user = req.user;\n  user.ultimaHoraNegociacao = advanceClock(user.ultimaHoraNegociacao, inc);\n  await user.save();\n  const minute = parseInt(user.ultimaHoraNegociacao.split(':')[1], 10);\n  const market = await loadMarketSnapshot(minute);\n  await executePendingOrders(user.id, market);\n  return res.json({ novaHoraNegociacao: user.ultimaHoraNegociacao, acoes: market });\n}\n\nexport async function addWatch(req, res) {\n  const { ticker } = req.body;\n  const existing = await AcaoInteresse.findOne({ where: { usuarioId: req.user.id, ticker } });\n  if (existing) return res.status(400).json({ error: 'AÃ§Ã£o jÃ¡ estÃ¡ na lista' });\n  const ordemMax = await AcaoInteresse.max('ordem', { where: { usuarioId: req.user.id } });\n  const acao = await AcaoInteresse.create({ usuarioId: req.user.id, ticker, ordem: (ordemMax || 0) + 1 });\n  return res.status(201).json({ id: acao.id, ticker: acao.ticker, message: 'AÃ§Ã£o adicionada Ã  lista' });\n}\n\nexport async function removeWatch(req, res) {\n  const { ticker } = req.params;\n  const deleted = await AcaoInteresse.destroy({ where: { usuarioId: req.user.id, ticker } });\n  if (!deleted) return res.status(404).json({ error: 'AÃ§Ã£o nÃ£o encontrada' });\n  return res.json({ message: `AÃ§Ã£o ${ticker} removida da lista` });\n}\n\nexport async function moveWatch(req, res) {\n  const { ticker } = req.params;\n  const { novaOrdem } = req.body;\n  const acao = await AcaoInteresse.findOne({ where: { usuarioId: req.user.id, ticker } });\n  if (!acao) return res.status(404).json({ error: 'AÃ§Ã£o nÃ£o encontrada' });\n  acao.ordem = novaOrdem;\n  await acao.save();\n  return res.json({ ticker, novaOrdem, message: 'Ordem atualizada' });\n}\n\nexport async function listWatch(req, res) {\n  const user = req.user;\n  const minute = parseInt(user.ultimaHoraNegociacao.split(':')[1], 10);\n  let watch = await AcaoInteresse.findAll({ where: { usuarioId: user.id }, order: [['ordem', 'ASC']] });\n  if (watch.length === 0) {\n    // gera 10 tickers random\n    const closing = await (await fetch('https://raw.githubusercontent.com/marciobarros/dsw-simulador-corretora/refs/heads/main/tickers.json')).json();\n    watch = closing.sort(() => 0.5 - Math.random()).slice(0, 10);\n    await Promise.all(watch.map((w, idx) => AcaoInteresse.create({ usuarioId: user.id, ticker: w.ticker, ordem: idx + 1 })));\n    watch = await AcaoInteresse.findAll({ where: { usuarioId: user.id }, order: [['ordem', 'ASC']] });\n  }\n  const market = await loadMarketSnapshot(minute);\n  const responseAcoes = watch.map((w) => market.find((m) => m.ticker === w.ticker)).filter(Boolean);\n  return res.json({ horaNegociacao: user.ultimaHoraNegociacao, acoes: responseAcoes });\n}\n"
  },
  {
    "diretorio": "src/controllers/ordersController.js",
    "conteudo": "import { OrdemCompra, OrdemVenda } from '../models/index.js';\nimport { executePendingOrders } from '../services/orderExecutionService.js';\nimport { loadMarketSnapshot } from '../services/priceService.js';\n\nexport async function registrarCompra(req, res) {\n  const { ticker, quantidade, modo, precoReferencia } = req.body;\n  if (quantidade <= 0) return res.status(400).json({ error: 'Quantidade invÃ¡lida' });\n  const ordem = await OrdemCompra.create({ usuarioId: req.user.id, ticker, quantidade, modo, precoReferencia: modo==='mercado'?null:precoReferencia });\n  if (modo === 'mercado') {\n    const minute = parseInt(req.user.ultimaHoraNegociacao.split(':')[1], 10);\n    const market = await loadMarketSnapshot(minute);\n    await executePendingOrders(req.user.id, market);\n    await ordem.reload();\n    return res.status(201).json(ordem);\n  }\n  return res.status(201).json({ ...ordem.toJSON(), message: 'Ordem de compra registrada' });\n}\n\nexport async function executarCompra(req, res) {\n  const { orderId } = req.body;\n  const ordem = await OrdemCompra.findOne({ where: { id: orderId, usuarioId: req.user.id, status: 'pendente' } });\n  if (!ordem) return res.status(404).json({ error: 'Ordem nÃ£o encontrada' });\n  const minute = parseInt(req.user.ultimaHoraNegociacao.split(':')[1], 10);\n  const market = await loadMarketSnapshot(minute);\n  await executePendingOrders(req.user.id, market);\n  await ordem.reload();\n  return res.json(ordem);\n}\n\nexport async function listarCompras(req, res) {\n  const { status } = req.query;\n  const where = { usuarioId: req.user.id };\n  if (status && status !== 'todas') where.status = status;\n  const ordens = await OrdemCompra.findAll({ where, order: [['createdAt','DESC']] });\n  res.json(ordens);\n}\n\nexport async function registrarVenda(req, res) {\n  const { ticker, quantidade, modo, precoReferencia } = req.body;\n  if (quantidade <= 0) return res.status(400).json({ error: 'Quantidade invÃ¡lida' });\n  const ordem = await OrdemVenda.create({ usuarioId: req.user.id, ticker, quantidade, modo, precoReferencia: modo==='mercado'?null:precoReferencia });\n  if (modo === 'mercado') {\n    const minute = parseInt(req.user.ultimaHoraNegociacao.split(':')[1], 10);\n    const market = await loadMarketSnapshot(minute);\n    await executePendingOrders(req.user.id, market);\n    await ordem.reload();\n    return res.status(201).json(ordem);\n  }\n  return res.status(201).json({ ...ordem.toJSON(), message: 'Ordem de venda registrada' });\n}\n\nexport async function executarVenda(req, res) {\n  const { orderId } = req.body;\n  const ordem = await OrdemVenda.findOne({ where: { id: orderId, usuarioId: req.user.id, status: 'pendente' } });\n  if (!ordem) return res.status(404).json({ error: 'Ordem nÃ£o encontrada' });\n  const minute = parseInt(req.user.ultimaHoraNegociacao.split(':')[1], 10);\n  const market = await loadMarketSnapshot(minute);\n  await executePendingOrders(req.user.id, market);\n  await ordem.reload();\n  return res.json(ordem);\n}\n\nexport async function listarVendas(req, res) {\n  const { status } = req.query;\n  const where = { usuarioId: req.user.id };\n  if (status && status !== 'todas') where.status = status;\n  const ordens = await OrdemVenda.findAll({ where, order: [['createdAt','DESC']] });\n  res.json(ordens);\n}\n"
  },
  {
    "diretorio": "src/controllers/walletController.js",
    "conteudo": "import { CarteiraItem } from '../models/index.js';\nimport { loadMarketSnapshot } from '../services/priceService.js';\n\nexport async function listarCarteira(req, res) {\n  const user = req.user;\n  const minute = parseInt(user.ultimaHoraNegociacao.split(':')[1], 10);\n  const market = await loadMarketSnapshot(minute);\n  const itens = await CarteiraItem.findAll({ where: { usuarioId: user.id } });\n  const acoesCarteira = itens.map((i) => {\n    const m = market.find((mm) => mm.ticker === i.ticker);\n    const valorTotalAtual = i.quantidade * m.precoAtual;\n    const ganhoPerdaUnitaria = m.precoAtual - i.precoCompraMedio;\n    return {\n      tickerAcao: i.ticker,\n      qtde: i.quantidade,\n      precoCompraMedio: Number(i.precoCompraMedio),\n      precoAtual: m.precoAtual,\n      valorTotalAtual,\n      ganhoPerdaUnitaria: Number(ganhoPerdaUnitaria.toFixed(2)),\n      ganhoPerdaTotal: Number((ganhoPerdaUnitaria * i.quantidade).toFixed(2)),\n      variacaoNominalDia: m.variacaoNominal,\n      variacaoPercentualDia: m.variacaoPercentual\n    };\n  });\n  const totalGanhosPerdas = acoesCarteira.reduce((acc, a) => acc + a.ganhoPerdaTotal, 0);\n  res.json({ horaNegociacao: user.ultimaHoraNegociacao, totalGanhosPerdas, acoesCarteira });\n}\n"
  },
  {
    "diretorio": "src/controllers/accountController.js",
    "conteudo": "import { ContaCorrente } from '../models/index.js';\n\nexport async function deposito(req, res) {\n  const { descricao, valor } = req.body;\n  if (valor <= 0) return res.status(400).json({ error: 'Valor invÃ¡lido' });\n  const ult = await ContaCorrente.findOne({ where: { usuarioId: req.user.id }, order: [['dataHora','DESC']] });\n  const saldoAtual = ult?.saldoApos ?? 0;\n  const novoSaldo = Number((saldoAtual + valor).toFixed(2));\n  const lanc = await ContaCorrente.create({ usuarioId: req.user.id, dataHora: new Date(), descricao, tipo: 'deposito', valor, saldoApos: novoSaldo });\n  res.json({ lancamentoId: lanc.id, ...lanc.toJSON(), message: 'DepÃ³sito registrado com sucesso' });\n}\n\nexport async function retirada(req, res) {\n  const { descricao, valor } = req.body;\n  if (valor <= 0) return res.status(400).json({ error: 'Valor invÃ¡lido' });\n  const ult = await ContaCorrente.findOne({ where: { usuarioId: req.user.id }, order: [['dataHora','DESC']] });\n  const saldoAtual = ult?.saldoApos ?? 0;\n  if (saldoAtual < valor) return res.status(400).json({ error: 'Saldo insuficiente' });\n  const novoSaldo = Number((saldoAtual - valor).toFixed(2));\n  const lanc = await ContaCorrente.create({ usuarioId: req.user.id, dataHora: new Date(), descricao, tipo: 'retirada', valor, saldoApos: novoSaldo });\n  res.json({ lancamentoId: lanc.id, ...lanc.toJSON(), message: 'Retirada registrada com sucesso' });\n}\n\nexport async function extrato(req, res) {\n  const lancs = await ContaCorrente.findAll({ where: { usuarioId: req.user.id }, order: [['dataHora','ASC']] });\n  res.json(lancs);\n}\n"
  },
  {
    "diretorio": "src/routes/auth.routes.js",
    "conteudo": "import { Router } from 'express';\nimport { register, login, logout, requestResetToken, resetPassword, changePassword } from '../controllers/authController.js';\nimport { authMiddleware } from '../middlewares/authMiddleware.js';\n\nconst router = Router();\nrouter.post('/register', register);\nrouter.post('/login', login);\nrouter.post('/logout', authMiddleware, logout);\nrouter.post('/pwd-token', requestResetToken);\nrouter.post('/reset-password', resetPassword);\nrouter.post('/change-password', authMiddleware, changePassword);\nexport default router;\n"
  },
  {
    "diretorio": "src/routes/market.routes.js",
    "conteudo": "import { Router } from 'express';\nimport { authMiddleware } from '../middlewares/authMiddleware.js';\nimport { clockTick, addWatch, removeWatch, moveWatch, listWatch } from '../controllers/marketController.js';\n\nconst router = Router();\nrouter.post('/clock', authMiddleware, clockTick);\nrouter.post('/watchlist', authMiddleware, addWatch);\nrouter.delete('/watchlist/:ticker', authMiddleware, removeWatch);\nrouter.put('/watchlist/:ticker/move', authMiddleware, moveWatch);\nrouter.get('/watchlist', authMiddleware, listWatch);\nexport default router;\n"
  },
  {
    "diretorio": "src/routes/orders.routes.js",
    "conteudo": "import { Router } from 'express';\nimport { authMiddleware } from '../middlewares/authMiddleware.js';\nimport { registrarCompra, executarCompra, listarCompras, registrarVenda, executarVenda, listarVendas } from '../controllers/ordersController.js';\n\nconst router = Router();\n// compras\nrouter.post('/buy', authMiddleware, registrarCompra);\nrouter.post('/buy/:orderId/execute', authMiddleware, executarCompra);\nrouter.get('/buy', authMiddleware, listarCompras);\n// vendas\nrouter.post('/sell', authMiddleware, registrarVenda);\nrouter.post('/sell/:orderId/execute', authMiddleware, executarVenda);\nrouter.get('/sell', authMiddleware, listarVendas);\nexport default router;\n"
  },
  {
    "diretorio": "src/routes/wallet.routes.js",
    "conteudo": "import { Router } from 'express';\nimport { authMiddleware } from '../middlewares/authMiddleware.js';\nimport { listarCarteira } from '../controllers/walletController.js';\n\nconst router = Router();\nrouter.get('/', authMiddleware, listarCarteira);\nexport default router;\n"
  },
  {
    "diretorio": "src/routes/account.routes.js",
    "conteudo": "import { Router } from 'express';\nimport { authMiddleware } from '../middlewares/authMiddleware.js';\nimport { deposito, retirada, extrato } from '../controllers/accountController.js';\n\nconst router = Router();\nrouter.post('/deposit', authMiddleware, deposito);\nrouter.post('/withdraw', authMiddleware, retirada);\nrouter.get('/statement', authMiddleware, extrato);\nexport default router;\n"
  },
  {
    "diretorio": "src/routes/index.js",
    "conteudo": "import { Router } from 'express';\nimport authRoutes from './auth.routes.js';\nimport marketRoutes from './market.routes.js';\nimport ordersRoutes from './orders.routes.js';\nimport walletRoutes from './wallet.routes.js';\nimport accountRoutes from './account.routes.js';\n\nconst router = Router();\nrouter.use('/auth', authRoutes);\nrouter.use('/market', marketRoutes);\nrouter.use('/orders', ordersRoutes);\nrouter.use('/wallet', walletRoutes);\nrouter.use('/account', accountRoutes);\nexport default router;\n"
  },
  {
    "diretorio": "src/migrations/202506140001-create-tabelas.js",
    "conteudo": "export async function up(queryInterface, Sequelize) {\n  await queryInterface.createTable('Usuarios', {\n    id: { type: Sequelize.INTEGER, autoIncrement: true, primaryKey: true },\n    email: { type: Sequelize.STRING, unique: true },\n    senhaHash: Sequelize.STRING,\n    ultimaHoraNegociacao: { type: Sequelize.STRING, defaultValue: '14:00' },\n    tokenRecSenha: Sequelize.STRING,\n    dataTokenRS: Sequelize.DATE,\n    createdAt: Sequelize.DATE,\n    updatedAt: Sequelize.DATE\n  });\n  await queryInterface.createTable('AcaoInteresses', {\n    id: { type: Sequelize.INTEGER, autoIncrement: true, primaryKey: true },\n    ticker: Sequelize.STRING,\n    ordem: Sequelize.INTEGER,\n    usuarioId: { type: Sequelize.INTEGER, references: { model: 'Usuarios', key: 'id' }, onDelete: 'CASCADE' },\n    createdAt: Sequelize.DATE,\n    updatedAt: Sequelize.DATE\n  });\n  await queryInterface.createTable('OrdemCompras', {\n    id: { type: Sequelize.INTEGER, autoIncrement: true, primaryKey: true },\n    ticker: Sequelize.STRING,\n    quantidade: Sequelize.INTEGER,\n    modo: Sequelize.ENUM('mercado','abaixo_de_preco'),\n    precoReferencia: Sequelize.DECIMAL(10,2),\n    precoExecucao: Sequelize.DECIMAL(10,2),\n    status: { type: Sequelize.ENUM('pendente','executada'), defaultValue: 'pendente' },\n    dataHoraExecucao: Sequelize.DATE,\n    usuarioId: { type: Sequelize.INTEGER, references: { model: 'Usuarios', key: 'id' }, onDelete: 'CASCADE' },\n    createdAt: Sequelize.DATE,\n    updatedAt: Sequelize.DATE\n  });\n  await queryInterface.createTable('OrdemVendas', {\n    id: { type: Sequelize.INTEGER, autoIncrement: true, primaryKey: true },\n    ticker: Sequelize.STRING,\n    quantidade: Sequelize.INTEGER,\n    modo: Sequelize.ENUM('mercado','a_partir_de_preco'),\n    precoReferencia: Sequelize.DECIMAL(10,2),\n    precoExecucao: Sequelize.DECIMAL(10,2),\n    status: { type: Sequelize.ENUM('pendente','executada'), defaultValue: 'pendente' },\n    dataHoraExecucao: Sequelize.DATE,\n    usuarioId: { type: Sequelize.INTEGER, references: { model: 'Usuarios', key: 'id' }, onDelete: 'CASCADE' },\n    createdAt: Sequelize.DATE,\n    updatedAt: Sequelize.DATE\n  });\n  await queryInterface.createTable('CarteiraItems', {\n    id: { type: Sequelize.INTEGER, autoIncrement: true, primaryKey: true },\n    ticker: Sequelize.STRING,\n    quantidade: Sequelize.INTEGER,\n    precoCompraMedio: Sequelize.DECIMAL(10,2),\n    usuarioId: { type: Sequelize.INTEGER, references: { model: 'Usuarios', key: 'id' }, onDelete: 'CASCADE' },\n    createdAt: Sequelize.DATE,\n    updatedAt: Sequelize.DATE\n  });\n  await queryInterface.createTable('ContaCorrentes', {\n    id: { type: Sequelize.INTEGER, autoIncrement: true, primaryKey: true },\n    dataHora: Sequelize.DATE,\n    descricao: Sequelize.STRING,\n    tipo: Sequelize.ENUM('deposito','retirada'),\n    valor: Sequelize.DECIMAL(10,2),\n    saldoApos: Sequelize.DECIMAL(10,2),\n    usuarioId: { type: Sequelize.INTEGER, references: { model: 'Usuarios', key: 'id' }, onDelete: 'CASCADE' },\n    createdAt: Sequelize.DATE,\n    updatedAt: Sequelize.DATE\n  });\n}\n\nexport async function down(queryInterface) {\n  await queryInterface.dropTable('ContaCorrentes');\n  await queryInterface.dropTable('CarteiraItems');\n  await queryInterface.dropTable('OrdemVendas');\n  await queryInterface.dropTable('OrdemCompras');\n  await queryInterface.dropTable('AcaoInteresses');\n  await queryInterface.dropTable('Usuarios');\n}\n"
  },
  {
    "diretorio": "README.md",
    "conteudo": "# Simulador de Corretora â€“ API RESTful (Node.js + Express + Sequelize)\n\nEste repositÃ³rio implementa todos os endpoints e lÃ³gica de negÃ³cio solicitados no **Trabalho DSW 2025**.\n\n## Passos rÃ¡pidos\n\n```bash\ncp .env.example .env      # edite com credenciais do seu MySQL\nnpm install               # instala dependÃªncias\nnpx sequelize-cli db:migrate   # cria schema no banco\nnpm run dev               # inicia em modo development com nodemon\n```\n\nA documentaÃ§Ã£o completa dos endpoints estÃ¡ em `src/routes/` e segue fielmente a especificaÃ§Ã£o fornecida.\n\n---\n**Good luck & happy coding!**\n"
  }
]
